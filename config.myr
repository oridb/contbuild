use std
use bio
use inifile

use "types"

pkg contbuild =
	const load	: (path : byte[:] -> build#)
;;

const load = {cfg
	var default : target
	var targs, ini
	var tmpdir, scratch, period, htmlstyle
	var logfile, logfd

	match inifile.load(cfg)
	| `std.Ok f:	ini = f
	| `std.Err e:	std.fatal("couldn't load {}: {}\n", cfg, e)
	;;

	/* global opts */
	tmpdir = std.pathcat(std.getenvv("TMP", "/tmp"), "contbuild-work")
	htmlstyle = inifile.getv(ini, "", "htmlstyle", "/style.css")
	scratch = inifile.getv(ini, "", "scratch", tmpdir)

	/* default 5 minute poll */
	match std.intparse(inifile.getv(ini, "", "period", "300"))
	| `std.Some v:	period = v * std.Sec
	| `std.None:	std.fatal("unable to parse 'period'\n")
	;;

	default.name = ""
	default.repo = inifile.getv(ini, "", "repo", "")
	default.remote = inifile.getv(ini, "", "remote", "")
	default.scratch = scratch

	/* report options */
	default.htmldir = inifile.getv(ini, "", "htmldir", "")
	default.htmlroot = inifile.getv(ini, "", "htmlroot", default.htmldir)
	default.htmlstyle = htmlstyle
	default.commiturl = inifile.getv(ini, "", "commiturl", "")
	default.email = inifile.getv(ini, "", "email", default.email)

	match inifile.get(ini, "", "build")
	| `std.Some b:	default.build = std.strtok(b)
	| `std.None:	default.build = std.sldup(["make"][:])
	;;
	match inifile.get(ini, "", "test")
	| `std.Some t:	default.test = std.strtok(t)
	| `std.None:	default.test = std.sldup(["make", "check"][:])
	;;
	match inifile.get(ini, "", "clean")
	| `std.Some c:	default.clean = std.strtok(c)
	| `std.None:	default.clean = std.sldup(["make", "clean"][:])
	;;
	match inifile.get(ini, "", "report")
	| `std.Some t:	default.report = std.strtok(t)
	| `std.None:	default.report = [][:]
	;;

	/* read the targets */
	targs = [][:]
	for s : inifile.bysection(ini)
		if s.len != 0
			std.slpush(&targs, loadtarg(ini, s, &default))
		;;
	;;

	/* read the build log */
	std.mkpath(scratch)
	logfile = std.pathcat(scratch, "contbuild.log")
	match std.openmode(logfile, std.Ordwr | std.Ocreat, 0o644)
	| `std.Ok fd:	logfd = fd
	| `std.Err e:	std.fatal("could not open build log {}: {}\n", logfile, e)
	;;
	std.slfree(logfile)

	readlog(targs, logfd)


	-> std.mk([
		.logfd=logfd,
		.targs=targs,
		.scratch=scratch,
		.period=period,
		.htmlstyle=htmlstyle,
	])
}

const loadtarg = {ini, s, default
	var scratch, htmldir, htmlroot, htmlbase, htmlstyle
	var commiturl, email
	var build, clean, test, report
	var repo, remote

	htmlbase = ""
	repo = inifile.getv(ini, s, "repo", default.repo)
	scratch = inifile.getv(ini, s, "scratch", default.scratch)
	remote = inifile.getv(ini, s, "remote", default.remote)
	htmldir = inifile.getv(ini, s, "htmldir", default.htmldir)
	htmlroot = inifile.getv(ini, s, "htmlroot", default.htmlroot)
	htmlstyle = inifile.getv(ini, s, "htmlstyle", default.htmlstyle)
	commiturl = inifile.getv(ini, s, "commiturl", default.commiturl)
	email = inifile.getv(ini, s, "email", default.email)
	if std.hasprefix(htmldir, htmlroot)
		htmlbase = std.pathcat("/", htmldir[htmlroot.len:])
	;;
	if htmlroot.len == 0
		htmlroot = std.sldup(htmlbase)
	;;

	match inifile.get(ini, s, "build")
	| `std.Some b:	build = std.strtok(b)
	| `std.None:	build = default.build
	;;
	match inifile.get(ini, s, "test")
	| `std.Some t:	test = std.strtok(t)
	| `std.None:	test = default.test
	;;
	match inifile.get(ini, s, "clean")
	| `std.Some c:	clean = std.strtok(c)
	| `std.None:	clean = default.clean
	;;
	match inifile.get(ini, s, "report")
	| `std.Some r:	report = std.strtok(r)
	| `std.None:	report = default.report
	;;


	-> std.mk([
		.name=std.sldup(s),
		.repo=repo,
		.scratch=scratch,
		.remote=remote,

		.build=build,
		.test=test,
		.clean=clean,
		.report=report,

		.htmldir=htmldir,
		.htmlroot=htmlroot,
		.htmlstyle=htmlstyle,
		.commiturl=commiturl,
		.email=email,

		._repo=std.pathcat(scratch, s),
		._htmlbase=htmlbase,
		._status=`Succ,
		._built=std.mkht(),
	])
}


const readlog = {targs, fd
	var recbuf : byte[:][4]
	var ht, f, rec : byte[:][:]

	ht = std.mkht()
	for t : targs
		std.htput(ht, t.name, t)
	;;
	f = bio.mkfile(fd, bio.Rd)
	for ln : bio.byline(f)
		rec = std.bstrtok(recbuf[:], ln)
		if rec.len == 4
			addresult(ht, rec[0], rec[1], rec[2], rec[3])
		;;
	;;
	bio.free(f)
	std.htfree(ht)
}

const addresult = {ht, hash, status, targ, branch
	var tt

	tt = std.htget(ht, std.strstrip(targ))
	match (tt, status)
	| (`std.Some t, "true"):
		std.htput(t._built, std.sldup(branch), std.sldup(hash))
		std.slpush(&t._hist, (std.sldup(hash), true))
		t._status = `Succ
	| (`std.Some t, "false"):
		std.htput(t._built, std.sldup(branch), std.sldup(hash))
		std.slpush(&t._hist, (std.sldup(hash), false))
		t._status = `Fail
	| _:
		std.put("skip:\t{}: {}: {}\n", hash, status, targ)
	;;
}
