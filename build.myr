use std
use sys
use bio
use thread

use "types"
use "repo"
use "report-html"
use "report-email"
use "report-cmd"

pkg contbuild =
	const run : (build : build# -> void)
;;

const run = {build
	for t : build.targs
		std.put("cloning {}...", t.repo)
		clone(t)
		std.put("done\n")
	;;

	while true
		for t : build.targs
			sync(t)
			runonce(build, t)

		;;
		std.put("run done, delaying {}s\n", build.period/std.Sec)
		std.usleep(build.period)
	;;
}

const runonce = {build, targ
	var brlist


	brlist = std.tryv(branches(targ), [][:])
	for (cm, br) : brlist
		thread.spawn({
			thread.semwait(&build.jobsem)
			runbranch(build, targ, cm, br)
			thread.sempost(&build.jobsem)
		})
	;;
	std.slfree(brlist)
}

const runbranch = {build, targ, cm, br
	var dir, idstr, idbuf : byte[32]
	var r, ok, id

	r = [
		.setup=[.cmd="", .out="", .err="", .ok=`Norun],
		.build=[.cmd="", .out="", .err="", .ok=`Norun],
		.test=[.cmd="", .out="", .err="", .ok=`Norun],
		.clean=[.cmd="", .out="", .err="", .ok=`Norun],
	]

	id = thread.xadd(&build.jobid, 1)
	idstr = std.bfmt(idbuf[:], "{}", id)
	dir = std.pathjoin([targ.scratch, idstr, targ.gosucks][:])
	std.put("test dir: {}\n", dir)
	std.mkpath(dir)
	for u : updates(targ, br, cm)
		if std.hthas(targ._commitstatus, u)
			continue
		;;
		std.put("testing {}:{}\n", br, cm)
		reset(&r)
		if !checkout(targ, dir, u)
			continue
		;;
		purge(targ, dir)
		ok = testrun(targ, dir, &r)

		thread.mtxlock(&build.reportmtx)
		report(build, targ, &r, ok, u, br)
		std.htput(targ._commitstatus, u, ok)
		thread.mtxunlock(&build.reportmtx)
	;;
	//deltree(dir)
	std.slfree(dir)
	std.slfree(cm)
	std.slfree(br)
}

const testrun = {t, dir, r
	-> runcmd(t, dir, t.setup, &r.setup) && \
		runcmd(t, dir, t.build, &r.build) && \
		runcmd(t, dir, t.test, &r.test) && \
		runcmd(t, dir, t.clean, &r.clean)
}

const updates = {targ, branch, commit
	thread.mtxlock(&targ._lock)
	match std.htget(targ._built, branch)
	| `std.None: 
		std.htput(targ._built, std.sldup(branch), std.sldup(commit))
		thread.mtxunlock(&targ._lock)
		-> std.sldup([std.sldup(commit)][:])
	| `std.Some old:
		match between(targ, old, commit)
		| `std.Ok r:
			std.slfree(old)
			std.htput(targ._built, branch, std.sldup(commit))
			thread.mtxunlock(&targ._lock)
			-> reverse(r)
		| `std.Err err:
			std.put("{}: unable to get updates for {}: {}\n",
			    targ.name, branch, err)
			std.slfree(err)
			thread.mtxunlock(&targ._lock)
			-> [][:]
		;;
	;;
}

const reverse = {lst
	for var i = 0; i < lst.len / 2; i++
		std.swap(&lst[i], &lst[lst.len - i - 1])
	;;
	-> lst
}

const report = {build, targ, report, status, hash, branch
	var changed

	changed = isok(targ._status) != status

	/* update the book keeping */
	match status
	| true:	targ._status = `Succ
	| _:	targ._status = `Fail
	;;
	std.fput(build.logfd, "{} {} {} {}\n", hash, status, targ.name, branch)
	std.slpush(&targ._hist, (std.sldup(hash), status))

	reporthtml(build, targ, report, hash)
	reportcmd(build, targ, report, hash)
	if changed
		reportemail(build, targ, report, hash)
	;;
}

const reset = {r
	resetcmd(&r.setup)
	resetcmd(&r.build)
	resetcmd(&r.test)
	resetcmd(&r.clean)
}

const resetcmd = {c
	set(&c.out, "")
	set(&c.err, "")
	c.ok = `Norun
}

const isok = {s
	match s
	| `Succ:	-> true
	| _:	-> false
	;;
}

const set = {s, v
	std.slfree(s#)
	s# = v
}

const runcmd = {t, dir, cmd, r
	if cmd.len == 0
		-> true
	;;
	set(&r.cmd, std.strjoin(cmd, " "))
	match readcmd(t, dir, cmd)
	| `std.Ok (out, err):
		set(&r.out, out)
		set(&r.err, err)
		r.ok = `Succ
	| `std.Err (out, err):
		set(&r.out, out)
		set(&r.err, err)
		r.ok = `Fail
	;;
	-> isok(r.ok)
}
