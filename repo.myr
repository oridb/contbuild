use std
use sys
use escfmt

use "types"

pkg contbuild =
	const clone	: (t : target# -> bool)
	const branches	: (t : target# -> std.result((byte[:], byte[:])[:], byte[:]))
	const head	: (t : target#, tip : byte[:] -> std.result(byte[:], byte[:]))
	const sync	: (t : target# -> bool)
	const between	: (t : target#, from : byte[:], to : byte[:] -> std.result(byte[:][:], byte[:]))
	const checkout	: (t : target#, ref : byte[:] -> bool)
	const purge	: (t : target# -> bool)
	const summary	: (t : target#, hash : byte[:] -> byte[:])
	const commitmsg	: (t : target#, hash : byte[:] -> byte[:])
	const readcmd	: (t : target#, cmd : byte[:][:] -> \
		std.result((byte[:], byte[:]), (byte[:], byte[:])))
;;

const clone = {t
	var raw, cmd

	raw = [][:]
	if t.remote.len == 0 && std.fexists(t._repo)
		-> true
	elif t.remote.len != 0
		raw = ["test", "-e", t._repo, "||"][:]
	;;

	cmd = munge(t, t.scratch, raw, ["git", "clone", t.repo, t._repo][:])
	match readrawcmd(t, cmd)
	| `std.Ok (r, e):
		std.slfree(r)
		std.slfree(e)
		-> true
	| `std.Err (r, e):
		std.put("could not clone: {}\n", e)
		std.slfree(r)
		std.slfree(e)
		-> false
	;;
}

const purge = {t
	match readcmd(t, ["git", "clean", "-xfd"][:])
	| `std.Ok (r, e):
		std.slfree(r)
		std.slfree(e)
		-> true
	| `std.Err (r, e):
		std.put("could not purge: {}\n", e)
		std.slfree(r)
		std.slfree(e)
		-> false
	;;
}

const branches = {t
	var branches
	var sp : byte[:][2]

	branches = [][:]
	match readcmd(t, ["git", "for-each-ref", 
		"--format=%(objectname);%(refname)", "refs/remotes/"][:])
	| `std.Ok (r, e):
		std.slfree(e)
		for b : std.bysplit(r, "\n")
			std.bstrsplit(sp[:], b, ";")
			sp[0] = std.strstrip(sp[0])
			sp[1] = std.strstrip(sp[1])
			std.slpush(&branches, (std.sldup(sp[0]), std.sldup(sp[1])))
		;;
		std.slfree(r)
		-> `std.Ok branches
	| `std.Err (r, e):
		std.slfree(r)
		-> `std.Err e
	;;
}

const head = {t, tip
	var s

	match readcmd(t, ["git", "show-ref", "-s", tip][:])
	| `std.Ok (r, e):
		s = std.sldup(std.strstrip(r))
		std.slfree(r)
		std.slfree(e)
		-> `std.Ok s
	| `std.Err (r, e):
		std.slfree(r)
		-> `std.Err e
	;;
}

const between = {t, from, to
	var range, ret

	if std.sleq(from, to)
		-> `std.Ok [][:]
	;;
	range = std.fmt("{}..{}", from, to)
	std.put("getting range {}\n", range)
	ret = [][:]
	match readcmd(t, ["git", "rev-list", range][:])
	| `std.Ok (r, e):
		std.slfree(range)
		std.slfree(e)
		for ln : std.bysplit(r, "\n")
			std.slpush(&ret, std.sldup(ln))
		;;
		-> `std.Ok ret
	| `std.Err (r, e):
		std.slfree(r)
		std.slfree(range)
		-> `std.Err e
	;;
}

const checkout = {t, rev
	std.put("checkout {}\n", rev)
	match readcmd(t, ["git", "checkout", "-f", rev][:])
	| `std.Ok (r, e):
		std.slfree(r)
		std.slfree(e)
		-> true
	| `std.Err (r, e):
		std.slfree(r)
		std.slfree(e)
		-> false
	;;
}

const sync = {t
	match readcmd(t, ["git", "fetch", "--all"][:])
	| `std.Ok (r, e):
		std.slfree(r)
		std.slfree(e)
		-> true
	| `std.Err (r, e):
		std.slfree(r)
		std.slfree(e)
		-> false
	;;
}

const summary = {t, hash
	-> showmsg(t, hash, "--format=%s")
}

const commitmsg = {t, hash
	-> showmsg(t, hash, "--format=%B")
}

const showmsg = {t, hash, fmt
	match readcmd(t, ["git", "show", "-s", fmt, hash][:])
	| `std.Ok (r, e):
		std.slfree(e)
		-> r
	| `std.Err (r, e):
		std.slfree(r)
		std.slfree(e)
		-> std.fmt("unknown commit {}", hash)
	;;
}

const readcmd = {t, cmd
	var r

	if t.remote.len == 0
		if !std.chdir(t._repo)
			-> `std.Err ("", std.fmt("could not chdir to {}\n", t._repo))
		;;
	;;

	cmd = munge(t, t._repo, [][:], cmd)
	r = readrawcmd(t, cmd)
	-> r
}

const Wnohang = 1
const readrawcmd = {t, cmd
	var res, st, out, err, ret
	var pfd : sys.pollfd[:]
	var buf : byte[8192]

	match std.espork(cmd)
	| `std.Ok (pid, stdin, stdout, stderr):
		std.close(stdin) /* give it an early EOF */
		res = 0
		st = 0
		out = ""
		err = ""
		pfd = [][:]
		std.slpush(&pfd, [.fd=(stdout : sys.fd), .events=sys.Pollin|sys.Pollhup, .revents=0])
		std.slpush(&pfd, [.fd=(stderr : sys.fd), .events=sys.Pollin|sys.Pollhup, .revents=0])
		while true
			res = sys.waitpid((pid : sys.pid), &st, Wnohang)
			/* No point in waiting if the child has already exited. */
			if res != 0 || sys.poll(pfd, 1000) < 0
				break
			;;
			
			for var i = 0; i < pfd.len; i++
				var p = &pfd[i]
				if p.revents != 0 && p.fd == (stdout : sys.fd)
					match std.read(stdout, buf[:])
					| `std.Err e:	out = std.fmt("unable to read fd {}: {}\n", p.fd, e)
					| `std.Ok 0:	std.sldel(&pfd, i)
					| `std.Ok n:	out = std.sljoin(&out, buf[:n])
					;;
					break
				elif p.revents != 0 && p.fd == (stderr : sys.fd)
					match std.read(stderr, buf[:])
					| `std.Err e:	out = std.fmt("unable to read fd {}: {}\n", p.fd, e)
					| `std.Ok 0:	std.sldel(&pfd, i)
					| `std.Ok n:	err = std.sljoin(&err, buf[:n])
					;;
					break
				;;
			;;
			if res != 0
				break
			;;
		;;

		match sys.waitstatus(st)
		| `sys.Waitexit 0:
			ret = `std.Ok (out, err)
		| _:    
			ret = `std.Err (out, err)
		;;

		std.close(stdout)
		std.close(stderr)
		std.slfree(pfd)
	| `std.Err e:
		ret = `std.Err ("", std.sldup("unable to execute"))
	;;
	for c : cmd
		std.slfree(c)
	;;
	std.slfree(cmd)
	-> ret
}

const munge = {t, dir, raw, cmd
	var command

	command = [][:]
	if t.remote.len == 0
		for c : raw
			std.slpush(&command, std.sldup(c))
		;;
		for c : cmd
			std.slpush(&command, std.sldup(c))
		;;
	else
		std.slpush(&command, std.sldup("ssh"))
		std.slpush(&command, std.sldup(t.remote))
		std.slpush(&command, std.sldup("cd"))
		std.slpush(&command, std.fmt("{}", escfmt.sh(dir)))
		std.slpush(&command, std.sldup("&&"))
		for c : raw
			std.slpush(&command, std.sldup(c))
		;;
		for c : cmd
			std.slpush(&command, std.fmt("{}", escfmt.sh(c)))
		;;
	;;
	-> command
}
